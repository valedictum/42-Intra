// client.c

/*
// ORIGINAL
void	handle_signal(int signal, siginfo_t *info, void *context)
{
	static unsigned char	assembled_byte = 0;
	static int				bit = 0;

	(void)info;
	(void)context;
	if (bit == 0)
	{
		assembled_byte = 0;
	}
	if (signal == SIGUSR1)
	{
		assembled_byte |= (0x01 << bit);
	}
	bit++;
	if (bit == 8)
	{
		write(1, &assembled_byte, 1);
		bit = 0;
	}
	else
	{
		assembled_byte <<= 1;
	}
}
*/

// SET 1
void handle_signal(int signal, siginfo_t *info, void *context)
{
	(void)info;
	(void)context;
	static int	i = 0;
	static int	bit = 0;

	if (signal == SIGUSR1)
		i |= (0x01 << bit);
	bit++;
	if (bit == 8)
	{
		//ft_printf("%c", i);
		write(1, &i, 1);
		bit = 0;
		i = 0;
	}
}

// SET 1
FUNCTION - setup_signal_handlers

USAGE - Sets up signal handlers for SIGUSR1 and SIGUSR2 using handle_signal
function to process them.

'sigaction' structure (sa) is set up to handle signalling behaviour.

'sa.sa_sigaction = handle_signal' assigns the signal handler 
function handle_signal to the sa_sigaction member of the struct sigaction 
and tells the system to call 'handle_signal' when a signal is received. 

'sa.sa_flags = SA_SIGINFO' sets the sa_flags member of the struct 
'sigaction' to SA_SIGINFO. This flag informs the operating system that the 
signal handler function is using extended information (siginfo_t and 
void *context parameters) instead of just the basic signal number.
SA_SIGINFO is a flag that tells the signal handler to expect 
extended information about the signal through the siginfo_t and
void *context parameters when handling the signal. This extended information 
can include details like the process ID of the sender etc. allowing for 
more detailed handling of signals.

'sigemptyset(&sa.sa_mask)' initialises the signal mask sa_mask to an empty set,
meaning no signals are blocked while the signal handler is executing allowing 
all signals to be delivered while the handler runs.

'sigaction(SIGUSR1, &sa, NULL)' sets up a signal handler for SIGUSR1 using the 
configuration specified in sa. The signal handler function handle_signal will 
handle SIGUSR1 signals. Same goes for SIGUSR2.

void	setup_signal_handlers(void)
{
	struct sigaction	sa;

	sa.sa_sigaction = handle_signal;
	sa.sa_flags = SA_SIGINFO;
	sigemptyset(&sa.sa_mask);
	sigaction(SIGUSR1, &sa, NULL);
	sigaction(SIGUSR2, &sa, NULL);
}

// SET 1
int	main(int argc, char **argv)
{
	int		i;
	int		pid;
	//char	*msg;

	i = 0;
	if (argc == 3)
	{
		//setup_signal_handlers();
		pid = mt_atoi(argv[1]);
		//msg = argv[2];
		//while (*msg != '\0')
		while(argv[2][i] != 0)
		{
			send_signal (pid, argv[2][i]);
			i++;
			//send_signal (pid, *msg);
			//msg++;
		}
		send_signal(pid, '\n');
		//pause();
	}
	else
	{
		ft_printf("Error!\nCorrect format is: ./client <PID> <MESSAGE>\n");
		return (-1);
	}
	return (0);
}
